## Lab8 实验报告

### 练习1: 完成读文件操作的实现（需要编码）

#### 实现思路

在`sfs_io_nolock` (Line 552, `kern/fs/sfs/sfs_inode.c`) 函数中，先计算一些辅助变量，并处理越界等特殊情况，然后开始进行读取/写入操作。我们需要实现的就是这一部分。该部分分为如下三个步骤：

1. 处理起始地址所在的那一块：如果起始地址`offset`就是对齐的，那么忽略这一步。否则，计算`offset`在块内偏移`blkoff`和待操作的大小`size`。先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_buf_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`，缓冲区指针`buf`前移，下一个需要操作的块号`blkno`自增1，待处理的块号`nblks`自减1。
2. 处理中间连续的完整的块：对于每一个块，`size`就是块大小，`blkoff`为0。先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_block_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`，缓冲区指针`buf`前移，下一个需要操作的块号`blkno`自增1，待处理的块号`nblks`自减1。
3. 处理最后没有对齐的那一块：这时，`blkoff`为0，先计算`size`。如果`size=0`，这一步就不需要做了。否则，先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_buf_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`。由于`buf, blkno, nblks`后面不再被使用，我们无需对其进行修改。

需要注意的是，上述操作中某一项调用失败，需要立即`goto out`来结束程序，这时由于已完成的大小和用户期待的大小不同，就相当于提醒用户文件读写的操作失败。

#### 给出设计实现“UNIX的PIPE机制”的概要设计方案

为简单起见，我们讨论形如`Process 1 | Process 2`的执行过程。管道利用fork机制建立，从而让两个进程Process 1和Process 2可以连接到同一个PIPE上。最开始的时候，图中的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭；Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了真实的PIPE。

![img](http://pic002.cnblogs.com/images/2012/426620/2012110216183818.jpg)

当Process 1向PIPE中写入时，它利用标准的库函数`write`完成向指定内存空间的写操作。当满足如下条件时，实际的内存复制工作才被执行：

- 内存中有足够的空间可容纳所有要写入的数据；
- 内存没有被Process 2锁定。

如果同时满足上述条件，首先锁定内存，然后复制数据。否则，Process 1休眠。当内存中有足够的空间可以容纳写入数据，或内存被解锁时（即Process 2唤醒Process 1时），Process 1被唤醒。当数据写入内存之后，释放锁，唤醒等待中的Process 2（如果有的话）。

Process 2从PIPE中读取也是类似的。

参考资料：[Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal)](http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html)

### 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）

#### 实现思路

流程同注释，详见`sfs_io_nolock` (Line 599, `kern/process/proc.c`)。

#### 给出设计实现基于“UNIX的硬链接和软链接机制”的概要设计方案

- 硬链接：在文件描述符中加入一个标记位和一个指针。当一个文件是硬链接时，标记位为1，而指针则指向链接的文件；
- 软链接：直接拷贝文件对应的`inode`信息。
